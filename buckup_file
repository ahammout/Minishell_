/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   buckup_file                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ahammout <ahammout@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/03/24 14:37:05 by ahammout          #+#    #+#             */
/*   Updated: 2023/04/06 17:19:47 by ahammout         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../includes/minishell.h"

void heredoc_action(t_data *data, int status, int fd[2])
{
    if (status == 0)
    {
        g_exit_status = 0;
        close(fd[1]);
        if (data->cmds->in_file != 0)
            close(data->cmds->in_file);
        data->cmds->in_file = fd[0];
        data->tokens->type = EMPTY;
        data->tokens->next->type = EMPTY;
        data->tokens = data->tokens->next->next;
    }
    else
    {
        g_exit_status = 130;
        close(fd[0]);
        close(fd[1]);
        free_env_list(data);
        free_data(data);
        main(1, NULL, list_to_str(data->env));
    }
}

void heredoc_sig_handler(int sig)
{
    (void)sig;
    exit(130);
}

void read_input(t_data *data, int fd[2])
{
    char *buffer;

    close(fd[0]);
    signal(SIGINT, heredoc_sig_handler);
    while (1)
    {
        buffer = readline("heredoc> ");
        if (!buffer)
            exit(130);
        if (ft_strcmp(buffer, data->tokens->next->lex) == 0)
        {
            free(buffer);
            break;
        }
        ft_putstr_fd(buffer, fd[1]);
        ft_putstr_fd("\n", fd[1]);
        free(buffer);
    }
    close(fd[1]);
    exit(0);
}

int heredoc_handler(t_data *data)
{
    int     fd[2];
    pid_t   pid;
    int     status;

    signal(SIGINT, SIG_IGN);
    if (pipe(fd) == -1)
        exit_minishell(data, "Minishell: pipe() failed.");
    pid = fork();
    if (pid == -1)
        exit_minishell(data, "Minishell: fork() failed.");
    if (pid == 0)
        read_input(data, fd);
    waitpid(pid, &status, 0);
    heredoc_action(data, status, fd);
    if (data->err)
        return (generate_error(data), 0);
    return (1);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   redirections_handler.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ahammout <ahammout@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/03/13 14:09:59 by ahammout          #+#    #+#             */
/*   Updated: 2023/04/06 17:16:08 by ahammout         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../includes/minishell.h"

char *no_such_file(char *file_name)
{
    char *error;

    error = ft_strjoin("Minshell: ", file_name);
    error = ft_strjoin_free1(error, ": No such file or directory");
    return (error);
}

void append_handler(t_data *data)
{
    if (data->tokens->type == APPEND)
        data->tokens = data->tokens->next;
    data->cmds->out_file = open(data->tokens->lex, O_WRONLY | O_APPEND);
    if (data->cmds->out_file == -1 && data->tokens->type != APPEND)
        data->cmds->out_file = open(data->tokens->lex, O_CREAT | O_WRONLY | O_APPEND, 0777);
    data->tokens->prev->type = EMPTY;
    data->tokens->type = EMPTY;
    data->tokens = data->tokens->next;
    if (data->tokens && data->tokens->type == REDOUT)
    {
        close(data->cmds->out_file);
        append_handler(data);
    }
}

int redin_handler(t_data *data)
{
    if (data->tokens && data->tokens->type == REDIN)
        data->tokens = data->tokens->next;
    data->cmds->in_file = open(data->tokens->lex, O_RDONLY);
    if (data->cmds->in_file == -1)
    {
        //// NO NEED TO GENERATE ERROR HERE {RETURN ONLY} => HANDLE IT IN EXECUTION.
        data->tokens->prev->type = EMPTY;
        data->tokens->type = EMPTY;
        data->err = no_such_file(data->tokens->lex);
        return (generate_error(data), 0);
    }
    data->tokens->prev->type = EMPTY;
    data->tokens->type = EMPTY;
    data->tokens = data->tokens->next;
    if (data->tokens && data->tokens->type == REDIN)
    {
        close(data->cmds->in_file);
        redin_handler(data);
    }
    if (data->err)
        return (0);
    return (1);
}

// int redirections_handler(t_data *data)
// {
//     if (data->tokens && is_redirection(data->tokens->type))
//     {
//         while (data->tokens && data->tokens->type != PIPE)
//         {
//             if (data->tokens && data->tokens->type == REDOUT)
//                 redout_handler(data);
//             else if (data->tokens && data->tokens->type == APPEND)
//                 append_handler(data);
//             else if (data->tokens && data->tokens->type == REDIN)
//             {
//                 if (!redin_handler(data))
//                     return (0);
//             }
//             else if (data->tokens->type == HEREDOC)
//             {
//                 if (!heredoc_handler(data))
//                     return (0);
//             }
//             else
//                 return (1);
//         }
//     }
//     exit(0);
//     return (1);
// }

// void    remove_redirection(t_data *data)
// {
//     data->tokens->prev->type = EMPTY;
//     data->tokens->type = EMPTY;
// }

void redout_handler(t_data *data)
{
    if (data->tokens->type == REDOUT)
        data->tokens = data->tokens->next;
    data->cmds->out_file = open(data->tokens->lex, O_WRONLY);
    if (data->cmds->out_file != -1 && data->tokens->type != REDOUT)
    {
        close(data->cmds->out_file);
        unlink(data->tokens->lex);
        data->cmds->out_file = open(data->tokens->lex, O_WRONLY | O_CREAT, 0777);
    }
    if (data->cmds->out_file == -1 && data->tokens->type != REDOUT)
        data->cmds->out_file = open(data->tokens->lex, O_WRONLY | O_CREAT, 0777);
    data->tokens->prev->type = EMPTY;
    data->tokens->type = EMPTY;
    data->tokens = data->tokens->next;
    if (data->tokens && data->tokens->type == REDOUT)
    {
        close(data->cmds->out_file);
        redout_handler(data);
    }
}

int redirections_handler(t_data *data)
{
    t_tokens *head;

    head = data->tokens;
    while (data->tokens && data->tokens->type != PIPE)
    {
        if (data->tokens && is_redirection(data->tokens->type))
        {
            if (data->tokens && data->tokens->type == REDOUT)
                redout_handler(data);
            else if (data->tokens && data->tokens->type == APPEND)
                append_handler(data);
            else if (data->tokens && data->tokens->type == REDIN)
            {
                if (!redin_handler(data))
                    return (0);
            }
            else if (data->tokens->type == HEREDOC)
            {
                if (!heredoc_handler(data))
                    return (0);
            }
        }
        else
            data->tokens = data->tokens->next;
    }
    data->tokens = head;
    return (1);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ahammout <ahammout@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/24 17:36:39 by ahammout          #+#    #+#             */
/*   Updated: 2023/04/06 16:47:32 by ahammout         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../includes/minishell.h"

char *join_arguments(t_data *data)
{
    char *arg;

    arg = ft_strdup("");
    while (data->tokens->attach)
    {
        if (data->tokens->type != EMPTY)
            arg = ft_strjoin_free1(arg, data->tokens->lex);
        data->tokens = data->tokens->next;
    }
    if (data->tokens->lex && data->tokens->type != EMPTY)
        arg = ft_strjoin_free1(arg, data->tokens->lex);
    return (arg);
}

int get_size(t_data *data)
{
    t_tokens *tmp;
    int size;

    tmp = data->tokens;
    size = 0;
    while (tmp && !is_redirection(tmp->type) && tmp->type != PIPE)
    {
        if (tmp->type != EMPTY)
        {
            if (tmp->attach)
            {
                while (tmp->attach)
                    tmp = tmp->next;
            }
            size++;
        }
        tmp = tmp->next;
    }
    return (size);
}

void command_arguments_handler(t_data *data)
{
    t_ref ref;
    char **str;
    int size;

    ref.i = 0;
    str = NULL;
    size = get_size(data);
    if (size)
    {
        str = malloc(sizeof(char *) * (size + 1));
        if (!str)
            exit_minishell(data, "Minishell: Allocation failed.");
        while (data->tokens && data->tokens->type != PIPE)
        {
            if (data->tokens->type != EMPTY)
            {
                if (data->tokens->attach)
                    str[ref.i] = join_arguments(data);
                else
                    str[ref.i] = ft_strdup(data->tokens->lex);
                ref.i++;
            }
            data->tokens = data->tokens->next;
        }
        str[ref.i] = NULL;
    }
    data->cmds->str = str;
}

t_exec *tokens_to_cmds(t_data *data)
{
    t_exec *head;
    t_tokens *ptr;

    init_cmds_list(data);
    head = data->cmds;
    ptr = data->tokens;
    while (data->tokens)
    {
        if (!redirections_handler(data))
        {
            data->tokens = ptr;
            data->cmds = head;
            return (free_data(data), (void *)0);
        }
        command_arguments_handler(data);
        if (data->tokens && data->tokens->type == PIPE)
            next_cmd(data);
    }
    data->cmds = head;
    data->tokens = ptr;
    free_tokens_list(data);
    return (head);
}

////////////////////////////////// PARSE_LINE //////////////////////////////

t_exec *parser(t_data *data)
{
    if (lexer(data))
    {
        if (syntax_analyzer(data))
        {
            // display_tokens(data->tokens);
            if (expander(data))
            {
                return (tokens_to_cmds(data));
            }
        }
    }
    return (0);
}
